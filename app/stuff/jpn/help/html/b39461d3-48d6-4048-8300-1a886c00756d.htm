<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:MSHelp="http://msdn.microsoft.com/mshelp" xmlns:mshelp="http://msdn.microsoft.com/mshelp" xmlns:ddue="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:msxsl="urn:schemas-microsoft-com:xslt"><head><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" /><META NAME="save" CONTENT="history" /><title>高度なデータ型の使用</title><meta name="Language" content="ja-jp" /><meta name="System.Keywords" content="高度なデータ型" /><meta name="Microsoft.Help.Id" content="b39461d3-48d6-4048-8300-1a886c00756d" /><meta name="Description" content="Microsoft JDBC Driver for SQL Server は、JDBC の高度なデータ型を使用して、SQL Server データ型を Java プログラミング言語によって認識できる形式に変換します。" /><meta name="Microsoft.Help.ContentType" content="Concepts" /><link rel="stylesheet" type="text/css" href="../local/Classic.css" /><script type="text/javascript" src="../scripts/EventUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/SplitScreen.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/Dropdown.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_manifold.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/script_feedBack.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CheckboxMenu.js">&amp;nbsp;</script><script type="text/javascript" src="../scripts/CommonUtilities.js">&amp;nbsp;</script><script type="text/javascript" src="../local/script_main.js">&amp;nbsp;</script></head><body><div id="header"><table id="bottomTable" cellpadding="0" cellspacing="0"><tr><td align="left"><span id="headerBold">高度なデータ型の使用</span></td></tr></table><table id="gradientTable"><tr><td class="nsrBottom" background="../icons/gradient.gif" /></tr></table></div><div id="mainSection"><div id="mainBody"><div class="introduction"><p>Microsoft JDBC Driver for SQL Server は、JDBC の高度なデータ型を使用して、SQL Server データ型を Java プログラミング言語によって認識できる形式に変換します。</p></div><h1 class="heading">解説</h1><div id="sectionSection0" class="section" name="collapseableSection" style=""><p>次の表は、SQL Server、JDBC、および Java プログラミング言語の高度なデータ型間で行われる既定のマッピングを示しています。</p><div class="tableSection"><table width="50%" cellspacing="2" cellpadding="5" frame="lhs"><tr><th><p>SQL Server 型</p></th><th><p>JDBC 型 (java.sql.Types)</p></th><th><p>Java 言語型</p></th></tr><tr><td><p>varbinary(max)</p><p>image</p></td><td><p>LONGVARBINARY</p></td><td><p>byte[] (既定)、Blob、InputStream、String</p></td></tr><tr><td><p>text</p><p>varchar(max)</p></td><td><p>LONGVARCHAR</p></td><td><p>String (既定)、Clob、InputStream</p></td></tr><tr><td><p>ntext</p><p>nvarchar(max)</p></td><td><p>LONGVARCHAR</p><p>LONGNVARCHAR (Java SE 6.0)</p></td><td><p>String (既定)、Clob、NClob (Java SE 6.0)</p></td></tr><tr><td><p>xml</p></td><td><p>LONGVARCHAR</p><p>SQLXML (Java SE 6.0)</p></td><td><p>String (既定)、InputStream、Clob、byte[]、Blob、SQLXML (Java SE 6.0)</p></td></tr><tr><td><p>udt</p></td><td><p>VARBINARY</p></td><td><p>String (既定)、byte[]、InputStream</p></td></tr></table></div><p>以下のセクションでは、JDBC ドライバーと高度なデータ型の使用方法の例を示します。</p></div><h1 class="heading">BLOB、CLOB、および NCLOB データ型</h1><div id="sectionSection1" class="section" name="collapseableSection" style=""><p>JDBC ドライバーは、java.sql.Blob、java.sql.Clob、および java.sql.NClob インターフェイスのすべてのメソッドを実装しています。</p><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>CLOB 値は、SQL Server 2005 (以降) の大きな値のデータ型で使用できます。特に、CLOB 型は <span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span> データ型と <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span> データ型で、BLOB 型は <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> データ型と <span sdata="langKeyword" value="image"><span class="keyword">image</span></span> データ型で、NCLOB 型は <span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span> と <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span> で使用できます。</p></div></div><h1 class="heading">大きな値のデータ型</h1><div id="sectionSection2" class="section" name="collapseableSection" style=""><p>以前のバージョンの SQL Server では、大きな値のデータ型には特殊な処理が必要でした。大きな値のデータ型とは、最大行サイズが 8 KB を超えるデータ型のことです。SQL Server では、<span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span>、<span sdata="langKeyword" value="nvarchar"><span class="keyword">nvarchar</span></span>、および <span sdata="langKeyword" value="varbinary"><span class="keyword">varbinary</span></span> データ型のための max 指定子により、最大 2^31 バイトの値を格納できます。テーブルの列と Transact-SQL 変数では、<span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span>、<span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span>、または <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> データ型を指定できます。</p><p>大きな値の型を操作する主要なシナリオには、データベースからの取得とデータベースへの追加があります。以下のセクションでは、これらのタスクを実行するためのさまざまな方法について説明します。</p><h1 class="heading">データベースからの大きな値の型の取得</h1><div class="subsection"><p><span sdata="langKeyword" value="varchar(max)"><span class="keyword">varchar(max)</span></span> データ型などのバイナリ以外の大きな値のデータ型をデータベースから取得する場合は、データを文字ストリームとして読み取ることができます。以下の例では、<a href="ec24963c-8b51-4838-91e9-1fbfa2347451.htm">SQLServerStatement</a> クラスの <a href="599cf463-e19f-4baa-bacb-513cad7c6cd8.htm">executeQuery</a> メソッドを使用してデータベースからデータを取得し、これを結果セットとして返します。次に、<a href="eaffcff1-286c-459f-83da-3150778480c9.htm">SQLServerResultSet</a> クラスの <a href="c70e210f-0288-47cc-9268-a29c45979729.htm">getCharacterStream</a> メソッドを使用し、大きな値のデータを結果セットから読み取ります。</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT TOP 1 * FROM Test1");
rs.next();
Reader reader = rs.getCharacterStream(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>この方法は、<span sdata="langKeyword" value="text"><span class="keyword">text</span></span>、<span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span>、および <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span> データ型に対しても使用できます。</p></div><p><span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> データ型などのバイナリの大きな値のデータ型をデータベースから取得する場合は、いくつかの方法があります。最も効率的に行うには、次のようにバイナリ ストリームとしてデータを読み取ります。</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
InputStream is = rs.getBinaryStream(2);</pre></span></div><p>また、<a href="d16a0aea-6144-4fcb-bcbc-5d7daa36d327.htm">getBytes</a> メソッドを使用し、次のように byte 配列としてデータを読み取ることもできます。</p><div class="sampleCode"><span codeLanguage="other"><pre>ResultSet rs = stmt.executeQuery("SELECT photo FROM mypics");
rs.next();
byte [] b = rs.getBytes(2);</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>BLOB としてデータを読み取ることもできます。ただし、前述の 2 つの方法より効率が下がります。</p></div></div><h1 class="heading">データベースへの大きな値の型の追加</h1><div class="subsection"><p>JDBC ドライバーを使用した大きいデータのアップロードは、メモリ内に収まる場合は、適切に行うことができます。メモリ内に収まらない場合は、ストリームを使用するのが主要なオプションです。ただし、最も効率的に大きいデータをアップロードするためには、ストリーム インターフェイスを使用します。</p><p>次に示すように、文字列やバイトを使用する方法もあります。</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (c1_id, c2_vcmax) VALUES (?, ?)");
pstmt.setInt(1, 1);
pstmt.setString(2, htmlStr);
pstmt.executeUpdate();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>この方法は、<span sdata="langKeyword" value="text"><span class="keyword">text</span></span>、<span sdata="langKeyword" value="ntext"><span class="keyword">ntext</span></span>、および <span sdata="langKeyword" value="nvarchar(max)"><span class="keyword">nvarchar(max)</span></span> 列に格納される値に対しても使用できます。</p></div><p>サーバーにイメージ ライブラリがあり、バイナリ イメージ ファイル全体を <span sdata="langKeyword" value="varbinary(max)"><span class="keyword">varbinary(max)</span></span> 列にアップロードする必要がある場合、JDBC ドライバーで最も効率的にこれを行うには、次に示すようにストリームを直接使用します。</p><div class="sampleCode"><span codeLanguage="other"><pre>PreparedStatement pstmt = con.prepareStatement("INSERT INTO test1 (Col1, Col2) VALUES(?,?)");
File inputFile = new File("CLOBFile20mb.jpg");
FileInputStream inStream = new FileInputStream(inputFile);
int id = 1;
pstmt.setInt(1,id);
pstmt.setBinaryStream(2, inStream);
pstmt.executeUpdate();
inStream.close();</pre></span></div><div style="margin: .5em 1.5em .5em 1.5em"><b></b><p>CLOB または BLOB メソッドの使用は、大きいデータをアップロードする際に効率的ではありません。</p></div></div><h1 class="heading">データベースの大きな値の型の変更</h1><div class="subsection"><p>多くの場合、データベースの大きい値を更新または変更する際は、UPDATE、WRITE、SUBSTRING などの Transact-SQL コマンドを使用して、<a href="a8481c06-fbba-432b-8c69-4f4619c20ad4.htm">SQLServerPreparedStatement</a> や <a href="30710a63-c05d-47d9-9cf9-c087a1c76373.htm">SQLServerCallableStatement</a> クラス経由でパラメーターを渡して行うことをお勧めします。</p><p>アーカイブされた HTML ファイルなどの大きいテキスト ファイル内で、ある単語を置き換える必要がある場合は、次のように <b>Clob</b> オブジェクトを使用することができます。</p><div class="sampleCode"><span codeLanguage="other"><pre>String SQL = "SELECT * FROM test1;";
Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);
ResultSet rs = stmt.executeQuery(SQL);
rs.next();

Clob clob = rs.getClob(2);
long pos = clob.position("dog", 1);
clob.setString(pos, "cat");
rs.updateClob(2, clob);
rs.updateRow();</pre></span></div><p>また、すべての作業をサーバー上で行い、準備された UPDATE ステートメントにパラメーターを渡すこともできます。</p><p>大きな値の型の詳細については、SQL Server オンライン ブックの「大きな値をとるデータ型の使用」を参照してください。</p></div></div><h1 class="heading">XML データ型</h1><div id="sectionSection3" class="section" name="collapseableSection" style=""><p>SQL Server は、XML ドキュメントとフラグメントを SQL Server データベースに格納できる <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> データ型を提供します。<span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> データ型は SQL Server の組み込みデータ型で、<span sdata="langKeyword" value="int"><span class="keyword">int</span></span> や <span sdata="langKeyword" value="varchar"><span class="keyword">varchar</span></span> などの他の組み込みデータ型といくつかの点で似ています。他の組み込み型と同様に、<span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> データ型は、テーブルの作成時に列型として使用したり、変数の型やパラメーターの型、関数の戻り値の型として使用したり、Transact-SQL CAST や CONVERT 関数内で使用したりすることができます。</p><p>JDBC ドライバーでは、<span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> データ型は、文字列、byte 配列、ストリーム、CLOB、BLOB、または SQLXML オブジェクトとしてマップできます。文字列が既定値です。JDBC Driver Version 2.0 以降では、SQLXML インターフェイスを導入した JDBC 4.0 API がサポートされます。SQLXML インターフェイスには、XML データを操作するための各種のメソッドが定義されています。<span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span> データ型は、SQL Server の <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> データ型にマップされます。<span sdata="langKeyword" value="SQLXML"><span class="keyword">SQLXML</span></span> Java データ型を使用して、リレーショナル データベースから XML データを読み取ったり、リレーショナル データベースに XML データを書き込んだりする方法については、「<span sdata="link"><a href="32b7217e-1f0c-473d-9a45-176daa81584e.htm">XML データのサポート</a></span>」を参照してください。</p><p>JDBC ドライバーにおける <span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> データ型の実装では、以下の操作がサポートされます。</p><ul><li><p>最も一般的なプログラミング シナリオに対し、標準 Java UTF-16 文字列として XML にアクセスできます。</p></li><li><p>UTF-8 および他の 8 ビットでエンコードされた XML を入力できます。</p></li><li><p>他の XML プロセッサやディスク ファイルとのやり取りのために UTF-16 でエンコードされている場合、先頭に BOM の付いた byte 配列として XML にアクセスできます。</p></li></ul><p>SQL Server は、UTF-16 でエンコードされた XML に対しては先頭の BOM が必要です。アプリケーションが BOM を提供する必要があるのは、XML パラメーター値が byte 配列として指定されている場合です。SQL Server は、BOM の付かない、または埋め込みのエンコーディング宣言を持たない UTF-16 文字列として常に XML 値を出力します。XML 値が byte[]、BinaryStream、または Blob として取得される場合、UTF-16 BOM が値の前に付いています。</p><p><span sdata="langKeyword" value="xml"><span class="keyword">xml</span></span> データ型の詳細については、SQL Server オンライン ブックの「xml データ型」を参照してください。</p></div><h1 class="heading">ユーザー定義データ型</h1><div id="sectionSection4" class="section" name="collapseableSection" style=""><p>SQL Server 2005 にユーザー定義型 (UDT) が導入されたことにより、オブジェクトやカスタム データ構造を SQL Server データベースに格納できるため、SQL 型システムを拡張することができます。UDT は複数のデータ型を持つことができ、動作を定義できます。この点は、1 つの SQL Server システム データ型から構成される従来の別名データ型と異なります。UDT は、検証可能なコードを生成する、Microsoft .NET 共通言語ランタイム (CLR) によってサポートされている任意の言語を使用して定義されます。その言語には、Microsoft Visual C# および Visual Basic .NET が含まれます。データは .NET Framework ベースのクラスまたは構造体のフィールドとプロパティとして公開され、動作はクラスまたは構造体のメソッドによって定義されます。</p><p>SQL Server では、UDT をテーブルの列定義、Transact-SQL バッチの変数、または Transact-SQL の関数やストアド プロシージャの引数として使用できます。</p><p>ユーザー定義データ型の詳細については、SQL Server オンライン ブックの「ユーザー定義型のインスタンスの使用と変更」を参照してください。</p></div><span id="seeAlsoSpan"><h1 class="heading">関連項目</h1></span><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><span sdata="link"><a href="7802328d-4d23-4775-9573-4169b127d258.htm">JDBC ドライバーのデータ型について</a></span></div></div></div><div id="footer" class="section"><span id="feedbackarea">このトピックに関する<a href="javascript:SubmitFeedback('DevDocs@Microsoft.com','','','','8.0.12060.10000','%0\dフィードバックありがとうございます。開発チームは、皆様からのフィードバックに基づいてドキュメントを改善しています。フィードバックを確認中、内容の確認または解決策に関するご意見をうかがうために電子メールをお送りする場合があります。お客様の電子メール アドレスをそれ以外の目的で使用することはありません。また、確認完了後はお客様の電子メール アドレス情報を削除させていただきます。%0\Aマイクロソフトのプライバシーに関する声明の詳細については、http://privacy.microsoft.com/ja-jp/default.aspx を参照してください。%0\A%0\d','カスタマー フィードバック');">フィードバック</a>を Microsoft にお送りください。</span><span id="copyrightarea"><p><a href="9bad553b-9e70-4696-8499-2e35f772a1e0.htm">© 2012 Microsoft.All rights reserved.</a></p></span></div></div></body></html>